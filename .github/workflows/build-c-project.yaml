name: Build .NET 8 Project

on:
  workflow_dispatch:
    inputs:
      configuration:
        description: 'Build configuration'
        required: true
        default: 'Release'
        type: choice
        options:
          - Debug
          - Release
      runtime:
        description: 'Target runtime'
        required: true
        default: 'win-x64'
        type: choice
        options:
          - win-x64
          - win-x86
          - win-arm64
      self_contained:
        description: 'Build self-contained executable'
        required: true
        type: choice
        options:
          - 'true'
          - 'false'
        default: 'true'
      create_release:
        description: 'Create a GitHub release after build'
        required: true
        type: choice
        default: 'false'
        options:
          - 'true'
          - 'false'
      release_tag:
        description: 'Release tag (required if create_release is true)'
        required: false
        default: ''
        type: string
      release_name:
        description: 'Release name'
        required: false
        default: 'BooruDatasetTagManager Release'
        type: string
      release_notes:
        description: 'Release notes'
        required: false
        default: 'Automated release from GitHub Actions'
        type: string

permissions:
  contents: write

jobs:
  build:
    name: Build ${{ inputs.configuration }} ${{ inputs.runtime }}
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        # with:
        #   submodules: "recursive"

      - name: Clone ScreenLister dependency
        run: |
          git clone https://github.com/starik222/ScreenLister.git ScreenLister
          cd ScreenLister
          git checkout master

      - name: Setup .NET 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Restore ScreenLister dependencies
        run: dotnet restore ScreenLister/ScreenList/ScreenListerNET.csproj

      - name: Build ScreenLister
        run: |
          msbuild ScreenLister/ScreenList/ScreenListerNET.csproj `
            /p:Configuration=Release `
            /p:Platform="Any CPU" `
            /p:TargetFramework=net6.0-windows `
            /t:Build `
            /v:minimal

      - name: Check ScreenLister build output
        shell: powershell
        run: |
          Write-Host "=== ScreenLister Directory Structure ==="
          Get-ChildItem -Path ScreenLister -Recurse -File | ForEach-Object {
            Write-Host "$($_.FullName)"
          }
          Write-Host ""
          Write-Host "=== Check for ScreenListerNET.dll ==="
          $dllPath1 = "ScreenLister\ScreenList\bin\Release\net6.0-windows\ScreenListerNET.dll"
          $dllPath2 = "ScreenLister\ScreenList\bin\Release\ScreenListerNET.dll"
          $dllPath3 = "ScreenLister\ScreenList\bin\Any CPU\Release\net6.0-windows\ScreenListerNET.dll"
          
          if (Test-Path $dllPath1) {
            Write-Host "[OK] DLL found at: $dllPath1"
            Get-Item $dllPath1 | Select-Object Name, Length, LastWriteTime
          } else {
            Write-Host "[NOT FOUND] DLL NOT found at: $dllPath1"
          }
          
          if (Test-Path $dllPath2) {
            Write-Host "[OK] DLL found at: $dllPath2"
            Get-Item $dllPath2 | Select-Object Name, Length, LastWriteTime
          } else {
            Write-Host "[NOT FOUND] DLL NOT found at: $dllPath2"
          }
          
          if (Test-Path $dllPath3) {
            Write-Host "[OK] DLL found at: $dllPath3"
            Get-Item $dllPath3 | Select-Object Name, Length, LastWriteTime
          } else {
            Write-Host "[NOT FOUND] DLL NOT found at: $dllPath3"
          }
          
          Write-Host ""
          Write-Host "=== Searching for all ScreenListerNET.dll files ==="
          Get-ChildItem -Path . -Recurse -Filter "ScreenListerNET.dll" -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "Found: $($_.FullName)"
          }

      - name: Restore dependencies
        run: dotnet restore BooruDatasetTagManager.sln

      - name: Check project references
        shell: powershell
        run: |
          Write-Host "=== Checking BooruDatasetTagManager.csproj references ==="
          $csprojPath = "BooruDatasetTagManager\BooruDatasetTagManager.csproj"
          $content = Get-Content $csprojPath -Raw
          if ($content -match "ScreenListerNET") {
            Write-Host "[OK] ScreenListerNET reference found in project file"
            if ($content -match "HintPath.*ScreenLister") {
              Write-Host "[OK] HintPath found"
              if ($content -match "HintPath.*?>([^<]+)") {
                $hintPath = $matches[1]
                Write-Host "  HintPath: $hintPath"
                $fullPath = Join-Path (Get-Location) $hintPath
                Write-Host "  Full path: $fullPath"
                if (Test-Path $fullPath) {
                  Write-Host "  [OK] DLL exists at HintPath location"
                } else {
                  Write-Host "  [NOT FOUND] DLL does NOT exist at HintPath location"
                }
              }
            }
          } else {
            Write-Host "[NOT FOUND] ScreenListerNET reference NOT found in project file"
          }

      - name: Copy ScreenLister DLL to expected location
        shell: powershell
        run: |
          Write-Host "=== Copying ScreenLister DLL ==="
          $sourcePath = "ScreenLister\ScreenList\bin\Any CPU\Release\net6.0-windows\ScreenListerNET.dll"
          $targetDir = "ScreenLister\ScreenList\bin\Release\net6.0-windows"
          $targetPath = Join-Path $targetDir "ScreenListerNET.dll"
          
          if (Test-Path $sourcePath) {
            Write-Host "Source DLL found at: $sourcePath"
            
            # Ensure target directory exists
            if (-not (Test-Path $targetDir)) {
              Write-Host "Creating target directory: $targetDir"
              New-Item -ItemType Directory -Path $targetDir -Force | Out-Null
            }
            
            # Copy DLL
            Copy-Item -Path $sourcePath -Destination $targetPath -Force
            Write-Host "[OK] DLL copied to: $targetPath"
            
            # Verify copy
            if (Test-Path $targetPath) {
              Write-Host "[OK] Copy verified"
              Get-Item $targetPath | Select-Object Name, Length, LastWriteTime
            } else {
              Write-Host "[ERROR] Copy failed"
            }
          } else {
            Write-Host "[ERROR] Source DLL not found at: $sourcePath"
          }

      - name: Build Solution
        run: |
          msbuild BooruDatasetTagManager.sln `
            /p:Configuration=${{ inputs.configuration }} `
            /p:Platform="Any CPU" `
            /p:TargetFramework=net8.0-windows `
            /t:Build `
            /v:minimal

      - name: Publish application
        run: |
          $selfContained = if ("${{ inputs.self_contained }}" -eq "true") { "--self-contained true" } else { "--self-contained false" }
          dotnet publish BooruDatasetTagManager/BooruDatasetTagManager.csproj `
            --configuration ${{ inputs.configuration }} `
            --runtime ${{ inputs.runtime }} `
            $selfContained `
            --output publish `
            /p:PublishSingleFile=true `
            /p:EnableCompressionInSingleFile=true

      - name: List published files
        shell: powershell
        run: |
          Write-Host "=== Published Files ==="
          Get-ChildItem -Path publish -Recurse -File | ForEach-Object {
            Write-Host "$($_.FullName) - $($_.Length) bytes"
          }

      - name: Create Release Archive
        if: inputs.create_release == 'true'
        shell: powershell
        run: |
          $config = "${{ inputs.configuration }}"
          $runtime = "${{ inputs.runtime }}"
          $archiveName = "BooruDatasetTagManager-${config}-${runtime}.zip"
          
          Write-Host "Creating release archive: $archiveName"
          
          # Create archive with all published files
          Compress-Archive -Path "publish\*" -DestinationPath $archiveName -Force
          
          Write-Host "Archive created successfully"
          Write-Host "Archive contents:"
          Get-ChildItem -Path publish -Recurse -File | ForEach-Object {
            Write-Host "  $($_.Name)"
          }

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ inputs.configuration }}-${{ inputs.runtime }}
          path: publish/
          retention-days: 30

      - name: Upload Release Archive
        if: inputs.create_release == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: release-archive-${{ inputs.configuration }}-${{ inputs.runtime }}
          path: BooruDatasetTagManager-${{ inputs.configuration }}-${{ inputs.runtime }}.zip
          retention-days: 30

  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    if: inputs.create_release == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Display structure of downloaded files
        run: ls -R artifacts

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.release_tag }}
          name: ${{ inputs.release_name }}
          body: ${{ inputs.release_notes }}
          draft: false
          prerelease: false
          files: |
            artifacts/release-archive-*/BooruDatasetTagManager-*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
